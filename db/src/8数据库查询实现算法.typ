#import "../template.typ":*

= 数据库查询实现算法
== Main Content
#qs([
#choice(
[ 已知 R和S 的参数 $B_R=B_S=10,000$, 可用内存页数目为 M。若要进行 R 和 S 的 $theta$-连接操作,没有索引可以使用,忽略结果存取的I/O次数。问：M 分别至少应是怎样的值,才能使磁盘的I/O次数不超过:
+ 200,000
+ 25,000
+ 20,000
结果正确的是],
dir: ttb,
a: [M > 630, M > 4700, M > 15000],
b: [M > 560, M > 6000, M > 20000],
c: [M > 530, M > 6700, M > 10000],
d: [M > 500, M > 10000, M > 30000],
ans: [])

],[
C 

为达到 $B_R + B_S = 20000$, 采用半主存实现即可，故 $M > 10000$ 时即可满足 I/O 次数不大于 20000 的要求，立得答案为 C。

考虑其他两种情况，使用大关系实现算法有：
$
  B_S + (B_S/(M-2)) * B_R lt.eq 200,000 | 25000
$

代入计算即可。

本题考察连接操作的物理实现，相关知识如下：
- 记号说明：
  - $B_R$：关系 R 的磁盘块数目
- 连接操作 $R join S$ 的物理实现算法（代价计算忽略存入结果）：
  - 基本实现：每次读一块 R，然后依次读入 S 的每一块进行匹配
    - 代价：$B_R + B_R * B_S$
  - 全主存实现：直接读入 R 和 S 的所有数据，然后进行匹配
    - 代价：$B_R + B_S$
  - 半主存实现：读入 R 的所有数据，然后读入 S 的每一块进行匹配
    - 代价：$B_R + B_S$
  - 大关系实现算法
    - 将主存 M 划分为 (M-2, 1, 1)
    - 将 S 划分为 $S/(M-2)$ 个子集，每次读入 M-2 块 S，1 块 R 进行匹配，剩下的一个内存块作为输出缓冲区
    - 代价：$B_S + (B_S/(M-2)) * B_R$
])

#qs([
#choice(
[已知关系R的参数如下：磁盘块数B(R) = 1000,元组数T(R) = 20000, R中属性A的不同值的个数记为V(R, A)=100。R上有基于属性A的排序索引。关于 $sigma_(a = 0) (R)$,下列说法正确的是],
dir: ttb,
a: [如果使用索引且索引是聚簇的,则该操作的执行代价为100个I/O;],
b: [如果使用索引且索引是非聚簇的,则该操作的执行代价为200个I/O;],
c: [如果R是聚簇存储的且不使用索引,则该操作的执行代价为1000个I/O;],
d: [如果不使用索引,则该操作的执行代价为1000个I/O;],
ans: [])
],[
C 
- A: 如果索引是聚簇的，可由索引直接找到聚簇块，代价为 $1000/100 = 10$ 个 I/O 
- B: 如果索引是非聚簇的，只能由索引找到元组，代价为 $20000/100 = 200$ 个 I/O
- C: 如果不使用索引，若 R 是聚簇存储的，$a=0$ 占 $1000/10$ 个块
  - 最好情况下，R 的第一个块即找到，代价为 10 个 I/O
  - 最坏情况下，R 的第 990 个块找到，代价为 990 + 10 = 1000个 I/O
  - 平均约 $(1000 + 10) / 2 = 505$ 个 I/O
- D: 如果不使用索引，需要考虑 R 是否聚簇存储，若非聚簇，则为 1000 个 I/O


本题考察基于索引的选择算法，相关知识如下：
- 记号说明：
  - $T_R$：关系 R 的元组数目
  - $V(R, A)$：关系 R 中属性 A 的不同值的个数
- 若索引是聚簇索引：I/O 代价 #sym.approx $B_R / V(R, K)$

- 若索引是非聚簇索引：I/O 代价 #sym.approx $T_R / V(R, K)$
])

#qs([
假设内存有 4 块,而待排序的数据块有 50 块,请给出归并次数最少的算法, 并且计算磁盘读写次数,给出过程。
],[
- $50 = 4 * 12 + 2$， 故初始归并段有 13 个，归并路数为 $4-1 = 3$ 路 
- 由于 $(13-1) mod (3-1) = 0$，不需要添加虚段
- 构造哈夫曼树如下：

#cetz.canvas({
  import cetz.draw: *
  import cetz.tree
  let data = (
    [50], 
    ([12], [4], [4], [4]),
    ([12], [4], [4], [4]),
    ([26],
    ([12], [4], [4], [4]),
    [4],
    ([10], [4], [4], [2])
    )
    )
  tree.tree(
    data,
    direction: "down",
    draw-node: (node, ..) => {
      circle((), radius: .35, fill: rgb("#a9e34b"), stroke: none)
      content((), text(black, [#node.content]))
    },
    draw-edge: (from, to, ..) => {
      let (a, b) = (from + ".center", to + ".center")
      line((a, .4, b), (b, .4, a))
    }
  )
})

磁盘读写次数为树的带权路径长度两倍，即：
$
  ((4*6) * 2 + (4*3) * 3 + 4*2 + (4+4+2) * 3) * 2 = 244
$
最后加上第一趟的 50*2 个 I/O，总代价为 344 个 I/O

本题考察两阶段多路归并排序算法(Two Phase Multi-way Merge Sort)，相关知识如下：
- 第一趟：划分子集并子集内部排序
- 第二趟：子集间归并

解题方式如下：(假定内存有 M 块)
- 第一趟：按 M 块进行划分，读入后做内部排序后写回
- 内存有 M 块，最多支持 M-1 路归并(一块作为输出缓冲区)
- 该问题为最佳归并问题(自行Google)，设初始归并段数为 n，归并路数为 K
  - 若 $(n-1) % (k-1) = u(u eq.not 0)$, 则添加 $(k-1) - u$ 个虚段(值为0)
  - 按哈夫曼树进行归并，每次选取最小的 k 个段进行归并，归并后生成一个新段
])

#qs([
#choice(
[基于散列的两趟算法和基于排序的两趟算法，其中第一趟都是划分子表，都要求子表的存储块数要小于可用内存数，以便子表可以一次性装入内存进行处理。关于划分子表，下列说法正确的是],
dir: ttb,
a: [基于排序的算法总是可以均匀地划分子表(即每个子表的大小都一样，除最后一块外)；基于散列的算法总是可以均匀地划分子表(即每个子表的大小都一样，除最后一块外)。 ],
b: [基于排序的算法不能保证总是均匀地划分子表；基于散列的算法不能保证总是均匀地划分子表。],
c: [基于排序的算法不能保证总是均匀地划分子表；基于散列的算法总是可以均匀地划分子表(即每个子表的大小都一样，除最后一块外)。],
d: [基于排序的算法总是可以均匀地划分子表(即每个子表的大小都一样，除最后一块外)；基于散列的算法不能保证总是均匀地划分子表。 ],
ans: [])
],[
D 

本题考察基于排序和基于散列的两趟算法，相关知识如下：
- 基于散列的两趟算法
  - 第一趟：用散列函数 $h_p$ 将原始关系分成 M-1 个子表并存储
  - 第二趟：对每个子表，用另一散列函数 $h_r$ 将其读入内存并建立内存结构，执行不同的操作处理
])

== Appendix

#board[
- 查询计划的执行策略：
  - 物化执行：运算的每个中间结果被创建 (物化),然后用于下一层的运算
    - 增加了查询执行的代价 （写入文件再读出）
    - 获得结果的时间延迟大
  - 流水线执行：将查询计划中若干操作组成流水线,一个操作的结果直接传给流水线中下一个操作
    - 避免产生临时关系及读写临时关系文件的I/O开销
    - 用户能够尽早得到查询结果
]