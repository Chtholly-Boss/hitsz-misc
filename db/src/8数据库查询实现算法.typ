#import "../template.typ":*

= 数据库查询实现算法
#qs([
#choice(
[​已知R和S的参数$B_R=B_S=10,000$，可用内存页数目为M。若要进行R和S的Theta-连接操作，没有索引可以使用，忽略结果存取的I/O次数。问：M分别应是怎样的值，才能使磁盘的I/O次数不超过(1)200,000，(2)25,000，(3)20,000。结果正确的是],
dir: ttb,
a: [M>630， M>4,700，M>15,000],
b: [M>560， M>6,000， M>20,000],
c: [M>530， M>6700，M>10,000],
d: [M>500， M>10,000，M>30,000],
ans: [])

],[
C 


])

#qs([
#choice(
[关于去重复&(R)操作的一趟扫描算法，下列说法不正确的是],
dir: ttb,
a: [算法可以做到只与一个内存块中的数据进行比较，即可判断出是否有重复；],
b: [算法可以边执行边建立内存数据结构，即仅对已处理过的数据建立内存数据结构。],
c: [非精确的讲，算法的应用前提是B(R) < =M，其中M为可用内存块数，B(R)为R中数据所占用的磁盘块数。  ],
d: [算法需要首先对R的所有数据建立内存数据结构，然后才能判断是否有重复的元组存在。],
ans: [D])

],[

])

#qs([
#choice(
[分组聚集操作的一趟扫描算法],
dir: ttb,
a: [算法可以做到一条记录只与一个或少量几个内存块中的数据进行分组聚集计算；],
b: [算法需要首先对R的所有数据建立内存数据结构，然后才能进行各个分组的聚集计算。],
c: [非精确的讲，算法的应用前提是B(R) < =M，其中M为可用内存块数，B(R)为R中数据所占用的磁盘块数。],
d: [算法可以边执行边建立内存数据结构，即仅对已处理过的数据建立内存数据结构，便可进行各个分组的聚集计算。],
ans: [D])

],[

])

#qs([
假设内存有 4 块,而待排序的数据块有 50 块,请给出归并次数最少的算法, 并且计算磁盘读写次数,给出过程。
],[

])

#qs([
#choice(
[已知关系R的参数如下：聚簇存储磁盘块数B(R) = 1,000，元组数T(R) = 20,000，R中属性A的不同值的个数记为V(R, A)=100。R上有基于属性A的排序索引。关于sA=0(R)，下列说法正确的是],
dir: ttb,
a: [如果R是聚簇存储的且使用索引，则该操作的执行代价平均为100个I/O；],
b: [如果R是聚簇存储的且使用索引，则该操作的执行代价为1000个I/O；],
c: [如果R是聚簇存储的且不使用索引，则该操作的执行代价为1000个I/O；],
d: [如果不使用索引，则该操作的执行代价为1000个I/O；],
ans: [C])
],[

])

#qs([
#choice(
[基于散列的两趟算法和基于排序的两趟算法，其中第一趟都是划分子表，都要求子表的存储块数要小于可用内存数，以便子表可以一次性装入内存进行处理。关于划分子表，下列说法正确的是],
dir: ttb,
a: [基于排序的算法总是可以均匀地划分子表(即每个子表的大小都一样，除最后一块外)；基于散列的算法总是可以均匀地划分子表(即每个子表的大小都一样，除最后一块外)。 ],
b: [基于排序的算法不能保证总是均匀地划分子表；基于散列的算法不能保证总是均匀地划分子表。],
c: [基于排序的算法不能保证总是均匀地划分子表；基于散列的算法总是可以均匀地划分子表(即每个子表的大小都一样，除最后一块外)。],
d: [基于排序的算法总是可以均匀地划分子表(即每个子表的大小都一样，除最后一块外)；基于散列的算法不能保证总是均匀地划分子表。 ],
ans: [])

],[

])
