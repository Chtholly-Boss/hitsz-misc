#import "utils.typ":*

= 词法分析

本部分主要对应教材 Chapter 3，考察的内容为正则表达式及 DFA。

本部分仅以作业中的题目为例，展示如何从正则文法出发，构造正则表达式及 DFA。

对于可直接构造正则表达式的题目，一般较为直接，不作举例。

#let v(content) = [\< #content \>]
#synex[
  (hw1) 设有如下文法：

  #align(center)[
    #v[标号说明] #to LABEL #v[标号表] \
    #v[标号表] #to d #v[标号段] \
    #v[标号段] #to d #v[标号段] | , #v[标号] | ; \
    #v[标号] #to d #v[标号段] 
  ]

  其中 {LABEL, d, ',', ';'} 为终结符集合

  (1) 写出该文法所产生语言的正则表达式

  (2) 写出该文法所产生语言的 DFA
]

(1) 借鉴左递归消除的方法，我们将非终结符进行编号:
// TODO 利用表格展示
- S0: 标号说明
- S1: 标号表
- S2: 标号
- S3: 标号段
注意到我们为标号赋予了更小的下标，这是因为以标号为左部的产生式比以标号段为左部的产生式更简单，便于后期化简。

记 LABEL = l, 我们重写文法为:
#align(center)[
  #v[S0] #to l #v[S1] \
  #v[S1] #to d #v[S3] \
  #v[S2] #to d #v[S3] \
  #v[S3] #to d #v[S3] | , #v[S2] | ;
]

注意到最后一条产生式中，右边出现了编号小于左边的非终结符，我们考虑将其进行代换，得到:
#align(center)[
  #v[S3] #to d #v[S3] | , d#v[S3] | ; \
]

进一步化简得: $#v[S3] #to (d | ,d)^\* ;$

因此我们可以得到 S0 所产生语言的正则表达式为: 
#align(center)[
  $
    #v[S0]  &#to l #v[S1] \
            &#to l d #v[S3] \
            &#to l d (d | ,d)^\* ; \
            &= "LABEL" d (d | ,d)^\* ; \
  $     
]

(2) DFA的构造较为简单，我们直接给出构造结果:

#figure(
  image("./assets/DFA.png", height: 35%), 
  caption: [
    正则表达式对应的DFA，摘自作业答案。
    其中错误态可以略去不画
  ]
)

#ex[
  - (2023 深圳) 有限状态自动机有且仅有一个唯一的终态. #ans([False])
]