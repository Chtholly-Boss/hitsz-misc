#import "utils.typ":*

= 目标代码生成

== 开销计算
该题型在作业和考试中均有出现，属于送分题型。

本课程的开销定义为：
- 指令固定开销：1
- 寄存器操作开销：0， 如 R, \*R(即取寄存器中的值)
- 其他操作开销：1
  - 如取常数, \#2
  - 如从非寄存器变量取值(寻址): \*a

详细的开销计算规则如下表：

#figure(
  image("assets/cost.png"),
  caption: "开销计算规则，取自教材表4.11"
)

#btw[按原书的说法，大致可以理解为寄存器可以和指令码一起放在一个word中，而其他信息(如常数)需要紧跟在这个word后面，使用一个额外的word来存储，因此需要额外开销]

#synex([
  (2023深圳) 计算下面程序的开销：
  #align(center)[
    ```yasm
      MOV x, R0
      MOV y, R1
      ADD R0, R1
    ```
  ]
  Sol: 3(指令数) + 2(x, y) = 5
])

#synex([
  (hw2) 计算下面程序的开销：
  #align(center)[
    ```yasm
      MOV p, R0
      MOV 0(R0), R1
      MOV R1, x
    ```
  ]
  Sol: 3(指令数) + 3(p, 0, x) = 6
])

=== 概念解释
本章涉及了部分概念，需要简单过一遍，考试时能描述大意即可。

#clues.example(title:"More Examples")[
  #show strong: set text(blue)
  - 指令选择(Instruction Selection): 寻找合适的*机器指令序列*以实现给定的*中间代码*
  - 寄存器分配(Register Allocation): 为程序中的某一点*选择驻留在寄存器中的一组变量*
  - 寄存器指派(Register Assignment): 确定变量要驻留的*具体寄存器*
  - 后续引用信息：变量在基本块的后继中*是否会被引用*以及*在哪里被引用*
  - 窥孔优化：用更小、更短的指令序列等价代替目标指令中的某些短序列
]

在本章中还涉及到了具体的代码生成，为防止考试中出现相关题目而吃了不理解含义的亏，此处给出若干代码生成示例，供大家参考。

#figure(
  image("assets/codegen-1.png"), 
  caption: "x := y op z 代码生成，摘自教材表11.2"
)

可以容易的看出寄存器描述符和地址描述符的作用，此处不再赘述。

另举例如下：
#ex[
  #show raw: set raw(lang: "yasm")
  - ` a := b[i] `
    - 做假设：a 在基本块中还会被引用，寄存器 R 可用，则将 a 放入 R 中
    - 分类讨论：
      - 若 i 在寄存器 Ri 中，则生成 `MOV b(Ri), R`
      - 若 i 不在寄存器中，则生成 `MOV i, R  MOV b(R), R`
  - ` a := *p`
    - 做假设：a 在基本块中还会被引用，寄存器 R 可用，则将 a 放入 R 中
    - 分类讨论：
      - 若 p 在寄存器 Ri 中，则生成 `MOV *Ri, R`
      - 若 p 不在寄存器中，则生成 `MOV p, R  MOV *R, R`
]

在了解一定的汇编知识的情况下，可以较轻松的完成代码生成，考试中若出现其他指令（如条件跳转）应当会给出指令说明，不再举例。
